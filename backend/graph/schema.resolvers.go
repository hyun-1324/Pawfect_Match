package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"database/sql"
	"fmt"
	"matchMe/graph/generated"
	"matchMe/graph/model"
)

// User resolves the user field on Bio type
func (r *bioResolver) User(ctx context.Context, obj *model.Bio) (*model.User, error) {
	return r.Query().User(ctx, obj.UserID)
}

// Size is the resolver for the size field.
func (r *bioResolver) Size(ctx context.Context, obj *model.Bio) (*float64, error) {
	if obj.Size == 0 {
		return nil, nil
	}
	size := float64(obj.Size)
	return &size, nil
}

// Sender is the resolver for the sender field.
func (r *messageResolver) Sender(ctx context.Context, obj *model.Message) (*model.User, error) {
	panic(fmt.Errorf("not implemented: Sender - sender"))
}

// Receiver is the resolver for the receiver field.
func (r *messageResolver) Receiver(ctx context.Context, obj *model.Message) (*model.User, error) {
	panic(fmt.Errorf("not implemented: Receiver - receiver"))
}

// UpdateProfile updates the current user's profile
func (r *mutationResolver) UpdateProfile(ctx context.Context, aboutMe *string) (*model.Profile, error) {
	userId, err := GetUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	_, err = r.DB.Exec("UPDATE users_profile SET about_me = $1 WHERE user_id = $2", aboutMe, userId)
	if err != nil {
		return nil, fmt.Errorf("failed to update profile: %v", err)
	}

	return r.Query().Profile(ctx, userId)
}

// UpdateBio updates the current user's bio preferences
func (r *mutationResolver) UpdateBio(ctx context.Context, preferredGender *string, preferredNeutered *bool, preferredDistance *int, preferredLocation *string) (*model.Bio, error) {
	userId, err := GetUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// First, get current bio to only update specified fields
	bio, err := r.Query().Bio(ctx, userId)
	if err != nil {
		return nil, err
	}

	// Update only the provided fields
	if preferredGender != nil {
		bio.PreferredGender = *preferredGender
	}
	if preferredNeutered != nil {
		bio.PreferredNeutered = *preferredNeutered
	}
	if preferredDistance != nil {
		bio.PreferredDistance = *preferredDistance
	}
	if preferredLocation != nil {
		bio.PreferredLocation = *preferredLocation
	}

	// Save updated bio
	_, err = r.DB.Exec(`
		UPDATE biographical_data 
		SET preferred_gender = $1, preferred_neutered = $2, preferred_distance = $3, preferred_location = $4
		WHERE user_id = $5`,
		bio.PreferredGender, bio.PreferredNeutered, bio.PreferredDistance, bio.PreferredLocation, userId)
	if err != nil {
		return nil, fmt.Errorf("failed to update bio: %v", err)
	}

	return bio, nil
}

// CreateConnection creates a new connection between users
func (r *mutationResolver) CreateConnection(ctx context.Context, userID string) (bool, error) {
	currentUserId, err := GetUserIDFromContext(ctx)
	if err != nil {
		return false, err
	}

	_, err = r.DB.Exec("INSERT INTO connections (user_id, target_id) VALUES ($1, $2)", currentUserId, userID)
	if err != nil {
		return false, fmt.Errorf("failed to create connection: %v", err)
	}

	return true, nil
}

// RemoveConnection removes a connection between users
func (r *mutationResolver) RemoveConnection(ctx context.Context, userID string) (bool, error) {
	currentUserId, err := GetUserIDFromContext(ctx)
	if err != nil {
		return false, err
	}

	_, err = r.DB.Exec("DELETE FROM connections WHERE user_id = $1 AND target_id = $2", currentUserId, userID)
	if err != nil {
		return false, fmt.Errorf("failed to remove connection: %v", err)
	}

	return true, nil
}

// User resolves the user field on Profile type
func (r *profileResolver) User(ctx context.Context, obj *model.Profile) (*model.User, error) {
	return r.Query().User(ctx, obj.UserID)
}

// User returns the user for a given ID
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	var user model.User
	var fileURL sql.NullString

	err := r.DB.QueryRow("SELECT users.id, users.dog_name, profile_pictures.file_url FROM users LEFT JOIN profile_pictures ON profile_pictures.user_id = users.id WHERE users.id = $1", id).Scan(
		&user.ID, &user.DogName, &fileURL)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("user with id %s not found", id)
		}
		return nil, fmt.Errorf("failed to fetch data for user: %v", err)
	}

	if fileURL.Valid {
		user.Picture = fileURL.String
	}

	return &user, nil
}

// Bio returns the bio for a given ID
func (r *queryResolver) Bio(ctx context.Context, id string) (*model.Bio, error) {
	var bio model.Bio
	bio.ID = id

	err := r.DB.QueryRow(`
		SELECT preferred_gender, preferred_neutered, dog_gender, dog_neutered, dog_size, 
		dog_energy_level, dog_favorite_play_style, dog_age, preferred_distance, preferred_location
		FROM biographical_data WHERE user_id = $1`, id).Scan(
		&bio.PreferredGender, &bio.PreferredNeutered, &bio.Gender, &bio.Neutered,
		&bio.Size, &bio.EnergyLevel, &bio.FavoritePlayStyle, &bio.Age,
		&bio.PreferredDistance, &bio.PreferredLocation)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("bio for user with id %s not found", id)
		}
		return nil, fmt.Errorf("failed to fetch bio for user: %v", err)
	}

	bio.UserID = id
	return &bio, nil
}

// Profile returns the profile for a given ID
func (r *queryResolver) Profile(ctx context.Context, id string) (*model.Profile, error) {
	var profile model.Profile
	profile.ID = id

	err := r.DB.QueryRow("SELECT about_me FROM users_profile WHERE user_id = $1", id).Scan(&profile.AboutMe)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("profile for user with id %s not found", id)
		}
		return nil, fmt.Errorf("failed to fetch profile for user: %v", err)
	}

	profile.UserID = id
	return &profile, nil
}

// Me returns the current authenticated user
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userId, err := GetUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	return r.User(ctx, userId)
}

// MyBio returns the bio of the current authenticated user
func (r *queryResolver) MyBio(ctx context.Context) (*model.Bio, error) {
	userId, err := GetUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	return r.Bio(ctx, userId)
}

// MyProfile returns the profile of the current authenticated user
func (r *queryResolver) MyProfile(ctx context.Context) (*model.Profile, error) {
	userId, err := GetUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	return r.Profile(ctx, userId)
}

// Recommendations returns a list of recommended users
func (r *queryResolver) Recommendations(ctx context.Context) ([]*model.User, error) {
	userId, err := GetUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	rows, err := r.DB.Query(`
		SELECT u.id, u.dog_name, pp.file_url 
		FROM users u
		LEFT JOIN profile_pictures pp ON pp.user_id = u.id
		WHERE u.id != $1 AND u.id NOT IN (
			SELECT target_id FROM connections WHERE user_id = $1
		) AND (
			SELECT COUNT(*) FROM recommendations WHERE user_id = $1 AND target_id = u.id
		) = 0 
		LIMIT 10`, userId)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch recommendations: %v", err)
	}
	defer rows.Close()

	var users []*model.User
	for rows.Next() {
		var user model.User
		var fileURL sql.NullString
		if err := rows.Scan(&user.ID, &user.DogName, &fileURL); err != nil {
			return nil, fmt.Errorf("error scanning recommendation: %v", err)
		}
		if fileURL.Valid {
			user.Picture = fileURL.String
		}
		users = append(users, &user)
	}

	return users, nil
}

// Connections returns a list of connected users
func (r *queryResolver) Connections(ctx context.Context) ([]*model.User, error) {
	userId, err := GetUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	rows, err := r.DB.Query(`
		SELECT u.id, u.dog_name, pp.file_url 
		FROM users u
		LEFT JOIN profile_pictures pp ON pp.user_id = u.id
		JOIN connections c ON c.target_id = u.id 
		WHERE c.user_id = $1`, userId)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch connections: %v", err)
	}
	defer rows.Close()

	var users []*model.User
	for rows.Next() {
		var user model.User
		var fileURL sql.NullString
		if err := rows.Scan(&user.ID, &user.DogName, &fileURL); err != nil {
			return nil, fmt.Errorf("error scanning connection: %v", err)
		}
		if fileURL.Valid {
			user.Picture = fileURL.String
		}
		users = append(users, &user)
	}

	return users, nil
}

// NewMessage subscribes to new messages for a user
func (r *subscriptionResolver) NewMessage(ctx context.Context, userID string) (<-chan *model.Message, error) {
	currentUserId, err := GetUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Only allow subscriptions to own messages
	if currentUserId != userID {
		return nil, fmt.Errorf("unauthorized: can only subscribe to own messages")
	}

	messages := make(chan *model.Message, 1)

	// This is a simplified implementation
	// In a real app, you would connect this to your existing WebSocket logic

	// For now, we're just creating an empty channel
	// The actual implementation would depend on how your websocket.go is implemented

	go func() {
		<-ctx.Done()
		close(messages)
	}()

	return messages, nil
}

// UserOnlineStatus subscribes to a user's online status changes
func (r *subscriptionResolver) UserOnlineStatus(ctx context.Context, userID string) (<-chan bool, error) {
	status := make(chan bool, 1)

	// This is a simplified implementation
	// In a real app, you would connect this to your existing WebSocket logic

	go func() {
		<-ctx.Done()
		close(status)
	}()

	return status, nil
}

// Bio resolves the bio field on User type
func (r *userResolver) Bio(ctx context.Context, obj *model.User) (*model.Bio, error) {
	return r.Query().Bio(ctx, obj.ID)
}

// Profile resolves the profile field on User type
func (r *userResolver) Profile(ctx context.Context, obj *model.User) (*model.Profile, error) {
	return r.Query().Profile(ctx, obj.ID)
}

// Bio returns generated.BioResolver implementation.
func (r *Resolver) Bio() generated.BioResolver { return &bioResolver{r} }

// Message returns generated.MessageResolver implementation.
func (r *Resolver) Message() generated.MessageResolver { return &messageResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Profile returns generated.ProfileResolver implementation.
func (r *Resolver) Profile() generated.ProfileResolver { return &profileResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

// Subscription returns generated.SubscriptionResolver implementation.
func (r *Resolver) Subscription() generated.SubscriptionResolver { return &subscriptionResolver{r} }

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

type bioResolver struct{ *Resolver }
type messageResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type profileResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
